"use client";

import { usePaletteStore } from "@/store/usePaletteStore";
import { useTheme } from "next-themes";
import { CSSProperties } from "react";
import { COLOR_ROLES } from "@/lib/paletteGenerator";
import { colord } from "colord";

interface ThemeScopeProps {
  children: React.ReactNode;
  forcedTheme?: "light" | "dark";
}

/**
 * Derives the foundational "canvas" tokens (background, foreground, card, border)
 * from a primary color.
 */
function deriveStructuralTokens(
  primaryHex: string,
  isDark: boolean,
): Record<string, string> {
  const primary = colord(primaryHex);
  const hsl = primary.toHsl();
  const h = hsl.h;
  const s = hsl.s;

  const primaryLuminance = primary.luminance();
  const primaryForeground = primaryLuminance > 0.35 ? "#09090b" : "#ffffff";

  if (isDark) {
    // Dark mode: deep dark background tinted with the primary hue
    const bg = colord({ h, s: Math.min(s * 0.15, 8), l: 5 }).toHex();
    const card = colord({ h, s: Math.min(s * 0.15, 8), l: 8 }).toHex();
    const border = colord({ h, s: Math.min(s * 0.2, 12), l: 18 }).toHex();
    const popover = card;

    return {
      "--background": bg,
      "--foreground": "#fafafa",
      "--card": card,
      "--card-foreground": "#fafafa",
      "--popover": popover,
      "--popover-foreground": "#fafafa",
      "--primary-foreground": primaryForeground,
      "--border": border,
      "--input": border,
      "--destructive": "#7f1d1d",
      "--destructive-foreground": "#fafafa",
    };
  } else {
    // Light mode
    const bg = colord({ h, s: Math.min(s * 0.1, 6), l: 98 }).toHex();
    const card = "#ffffff";
    const border = colord({ h, s: Math.min(s * 0.2, 12), l: 88 }).toHex();
    const popover = card;

    return {
      "--background": bg,
      "--foreground": "#09090b",
      "--card": card,
      "--card-foreground": "#09090b",
      "--popover": popover,
      "--popover-foreground": "#09090b",
      "--primary-foreground": primaryForeground,
      "--border": border,
      "--input": border,
      "--destructive": "#ef4444",
      "--destructive-foreground": "#ffffff",
    };
  }
}

export function ThemeScope({ children, forcedTheme }: ThemeScopeProps) {
  const { colors } = usePaletteStore();
  const { theme, systemTheme } = useTheme();

  // Robustly determine the current mode
  const currentTheme =
    forcedTheme || (theme === "system" ? systemTheme : theme);
  const isDark = currentTheme === "dark";
  const mode = isDark ? "darkHex" : "lightHex";

  const style: CSSProperties & Record<string, string> = {
    // Force the browser color scheme to match, ensuring native inputs/scrollbars adapt
    colorScheme: isDark ? "dark" : "light",
  };

  const setVar = (name: string, value: string) => {
    if (value && value.startsWith("#")) {
      style[name] = value;
    }
  };

  // 1. Structural Tokens (Background, Border, etc.)
  const primaryColor = colors[0];
  if (primaryColor) {
    // We pass the specific mode hex (lightHex or darkHex) to derive tokens
    const structuralTokens = deriveStructuralTokens(primaryColor[mode], isDark);
    Object.entries(structuralTokens).forEach(([key, value]) => {
      style[key] = value;
    });
  }

  // 2. Palette Colors
  colors.forEach((color, index) => {
    const role = COLOR_ROLES[index];
    if (!role) return;

    // Explicitly use the current mode's hex (generated by palette)
    const hex = color[mode];
    setVar(`--${role}`, hex);

    const lum = colord(hex).luminance();
    const fg = lum > 0.5 ? "#09090b" : "#ffffff";
    setVar(`--${role}-foreground`, fg);
  });

  // 3. Fallbacks
  const fallbackMap: Record<string, number> = {
    secondary: 0,
    accent: 1,
    ring: 0,
  };

  COLOR_ROLES.forEach((role, i) => {
    if (colors[i]) return;

    // Muted fallback
    if (role === "muted") {
      const base = colors[0];
      if (base) {
        // Derive a proper muted color suitable for the current mode
        const mutedHex = isDark
          ? colord(base[mode]).desaturate(0.6).darken(0.3).toHex()
          : colord(base[mode]).desaturate(0.6).lighten(0.1).toHex();

        setVar("--muted", mutedHex);
        setVar("--muted-foreground", isDark ? "#a1a1aa" : "#71717a");
        return;
      }
    }

    const fallbackIndex = fallbackMap[role];
    if (fallbackIndex !== undefined) {
      const fallbackColor = colors[fallbackIndex] ?? colors[0];
      if (fallbackColor) {
        setVar(`--${role}`, fallbackColor[mode]);
        const lum = colord(fallbackColor[mode]).luminance();
        const fg = lum > 0.5 ? "#09090b" : "#ffffff";
        setVar(`--${role}-foreground`, fg);
      }
    }
  });

  // 4. Charts
  const chartCount = 5;
  for (let i = 0; i < chartCount; i++) {
    const color = colors[i % colors.length];
    if (color) setVar(`--chart-${i + 1}`, color[mode]);
  }

  return (
    <div style={style as CSSProperties} className="contents">
      {children}
    </div>
  );
}
